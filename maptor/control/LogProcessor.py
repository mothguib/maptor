# -*- coding: utf-8 -*-

import sys
import os
import json

import numpy as np

import maptor.util.misc as misc
from maptor.control import BinaryProcessor
from maptor import Paths

sys.path.append(Paths.LOCALPYTROL)
from pytrol.util import pathformatter as pf


class LogProcessor(BinaryProcessor):
    """
    A kind of processor providing various methods and tools with the aim to
    process log files generated by the simulator Pytrol.
    """

    @staticmethod
    def load_log(log_fp: str, tpl: str, agts_log_fp: str = None):
        """
        Loads the log files of an execution.

        :param log_fp: file path of the log file of a given execution,
        containing 3D-positions of agents to process
        :type log_fp: str
        :param agts_log_fp: path of the log file of a given execution,
        containing the individual idlenesses of agents
        :type agts_log_fp:
        :param tpl: map id
        :type tpl: int or str
        :return:
        :rtype:
        """

        # `graph`: a list representing the map as graph
        # `seqs_pos`: a list representing the "paths" of agents also known as
        #  the "sequence of positions" of agents
        # `seqs_ridls`: a list representing the real idlenesses for each period
        # over all the execution
        # `mts`: a list representing the metrics of the execution
        graph, seqs_pos, seqs_ridls, mts = BinaryProcessor.load_log(log_fp,
                                                                    tpl)

        seqs_viidls = []

        if agts_log_fp is not None:
            with open(agts_log_fp, 'r') as s:
                seqs_viidls = json.load(s)

        return graph, seqs_pos, seqs_ridls, mts, seqs_viidls

    @classmethod
    def log_to_binpos_and_idls(cls,
                               seqs_pos: list,
                               seqs_viidls: list,
                               seqs_ridls: list,
                               graph: np.ndarray) -> (list, list, list):
        """
        Computes sequences of on-vertex individual idlenesses,
        on-vertex binary positions and on-vertex real idlenesses
        corresponding to the ones passed as arguments, respectively. Method
        designed only for traces generated by a strategy with coordinator.

        :param seqs_ridls: sequences of on-vertex real idlenesses for each time
        step.
        :type: seqs_ridls:
        Shape: `T x N_vts`.
        :param seqs_pos: sequences of 3D positions for every agent and for each
        time step.
        Shape: `T x N_agts x 3`.
        :type seqs_pos: list
        :param seqs_viidls: sequences - one per agent - of individual
        idlenesses.
        Shape: `N_agts x T x N_vts`.
        :type seqs_viidls: list
        :param graph: the graph standing for the map
        :type graph: list
        :return:
        :rtype:
        """

        # Duration of the given execution: total number of periods
        duration = len(seqs_pos)
        num_agts = len(seqs_pos[0]) - 1  # -1 because the coordinator is not
        # taking into account
        num_vertices = len(graph)

        # Binary positions of agents for all the execution. Shape:
        # `T' x N_agts x N_vts`, where `T'` is the length of the initial
        # sequence with only the vertex positions.
        b_pos = []

        # Individual idlenesses for each agent while standing on a vertex
        #  for all executions. Shape: `N_agts x T' x N_vts`, where
        # `T'` is the length of the initial sequence containing only the vertex
        # positions.
        viidls = []

        # Real idlenesses for each agent while standing on a vertex for all
        #  executions. Shape: `N_agts x T' x N_vts`, where `T` is
        #  the length of positions sequence containing only vertex positions.
        idls = []

        # Loop over the agents
        for i in range(num_agts):
            b_pos_a = []
            viidls_a = []
            idls_a = []

            # Loop over the time
            for t in range(duration):
                # i + 1 because the first agent is the coordinator
                if seqs_pos[t][i + 1][1] == -1:  # if seqs_pos[t][i + 1][1],
                    # == -1, then the second coordinate of the position vector
                    #  is equal to -1 and thereby the position is a vertex
                    pos = [0] * num_vertices
                    pos[seqs_pos[t][i + 1][0]] = 1

                    b_pos_a += [pos]
                    viidls_a += [seqs_viidls[i + 1][t]]
                    idls_a += [seqs_ridls[t]]

            # The binary positions
            b_pos += [b_pos_a]
            # The on-vertex individual idlenesses
            viidls += [viidls_a]
            # The on-vertex real idlenesses
            idls += [idls_a]

        return b_pos, viidls, idls

    @classmethod
    def log_to_veidls_and_idls(cls,
                               seqs_pos: list,
                               seqs_viidls: list,
                               seqs_veidls: list,
                               seqs_ridls: list) -> (list, list, list):
        """
        Computes sequences of on-vertex individual idlenesses,
        on-vertex estimated idlenesses and on-vertex real idlenesses
        corresponding to the ones passed as arguments, respectively. Method
        designed only for traces generated by a strategy with coordinator.

        :param seqs_veidls:
        :type seqs_veidls:
        :param seqs_ridls: sequences of on-vertex real idlenesses for each time
        step.
        :type: seqs_ridls:
        Shape: `T x N_vts`.
        :param seqs_pos: sequences of 3D positions for every agent and for each
        time step.
        Shape: `T x N_agts x 3`.
        :type seqs_pos: list
        :param seqs_viidls: sequences - one per agent - of individual
        idlenesses.
        Shape: `N_agts x T x N_vts`.
        :type seqs_viidls: list
        :return:
        :rtype:
        """

        # Duration of the given execution: total number of periods
        duration = len(seqs_pos)
        num_agts = len(seqs_pos[0])

        # Estimated idlenesses for each agent while standing on a vertex
        #  for all executions. Shape: `N_agts x T' x N_vts`, where
        # `T'` is the length of the initial sequence containing only the vertex
        # positions.
        veidls = []

        # Individual idlenesses for each agent while standing on a vertex
        #  for all executions. Shape: `N_agts x T' x N_vts`, where
        # `T'` is the length of the initial sequence containing only the vertex
        # positions.
        viidls = []

        # Real idlenesses for each agent while standing on a vertex for all
        #  executions. Shape: `N_agts x T' x N_vts`, where `T` is
        #  the length of positions sequence containing only vertex positions.
        idls = []

        # Loop over the agents
        for i in range(num_agts):
            veidls_a = []
            viidls_a = []
            idls_a = []

            # Loop over the time
            for t in range(duration):
                if seqs_pos[t][i][1] == -1:  # if seqs_pos[t][i][1] == -1,
                    # then the second coordinate of the position vector
                    #  is equal to -1 and thereby the position is a vertex
                    veidls_a += [seqs_veidls[i][t]]
                    viidls_a += [seqs_viidls[i][t]]
                    idls_a += [seqs_ridls[t]]

            # The binary positions
            veidls += [veidls_a]
            # The on-vertex individual idlenesses
            viidls += [viidls_a]
            # The on-vertex real idlenesses
            idls += [idls_a]

        return veidls, viidls, idls

    @classmethod
    def generate_binpos_and_idls(cls,
                                 log_fp: str,
                                 agts_log_fp: str):
        """
        Generates the on-vertex binary positions, on-vertex
        individual and on-vertex global idlenesses corresponding to the log
        of the execution `exec_id`.

        :param log_fp: file path of the log file of a given execution,
        containing 3D-positions of agents to process
        :type log_fp: str
        :param agts_log_fp: path of the log file of a given execution,
        containing the individual idlenesses of agents
        :type agts_log_fp:
        :return:
        :rtype:
        """
        strt, variant, tpl, soc_name, nagts, duration, exec_id = \
            pf.filepath_to_exec_params(log_fp)

        graph, seqs_pos, seqs_ridls, mts, seqs_viidls \
            = cls.load_log(log_fp=log_fp, tpl=tpl, agts_log_fp=agts_log_fp)

        # `log_to_binpos_and_idls` returns b_pos, viidls, vidls such that:
        # * `b_pos`: binary positions of agents for all the execution.
        # Shape: `T' x N_agts x N_vts`, where `T'` is the length of the initial
        # sequence with only the vertex positions.
        # * `viidls`: individual idlenesses for each agent while standing on
        # a vertex for all executions.
        # Shape: `N_agts x T' x N_vts`, where `T'` is the length of the
        # initial sequence containing only the vertex positions.
        # * `idls`: real idlenesses for each agent while standing on a vertex
        #  for all executions.
        # Shape: `N_agts x T' x N_vts`, where `T` is the length of positions
        #  sequence containing only vertex positions.
        return cls.log_to_binpos_and_idls(seqs_pos,
                                          seqs_viidls,
                                          seqs_ridls, graph)

    @classmethod
    def generate_save_binpos_and_idls(cls,
                                      log_fp: str,
                                      agts_log_fp: str,
                                      soc_name: str = None,
                                      binpos_rep: str = Paths.LOCALBIN,
                                      viidls_rep: str = Paths.LOCALVIIDLS,
                                      vidls_rep: str = Paths.LOCALVIDLS) \
            -> (str, str, str):
        """
        Generates and saves the on-vertex binary positions, on-vertex
        individual and on-vertex global idlenesses corresponding to the log
        of the execution `exec_id`, each one in the corresponding file.

        :param log_fp: file path of the log file of a given execution,
        containing 3D-positions of agents to process
        :type log_fp: str
        :param agts_log_fp: path of the log file of a given execution,
        containing the individual idlenesses of agents
        :type agts_log_fp:
        :param soc_name:
        :type soc_name:
        :param binpos_rep: Repository of the binary position logs
        :type binpos_rep: str
        :param viidls_rep: Repository of the on-vertex individual
        idleness logs
        :type viidls_rep: str
        :param vidls_rep: Repository of the on-vertex real idleness logs
        :type vidls_rep: str
        :return:
        :rtype:
        """

        strt, variant, tpl, soc_name, nagts, duration, exec_id = \
            pf.filepath_to_exec_params(log_fp)

        # * `b_pos`: binary positions of agents for all the execution.
        # Shape: `T' x N_agts x N_vts`, where `T'` is the length of the initial
        # sequence with only the vertex positions.
        # * `viidls`: individual idlenesses for each agent while standing on
        # a vertex for all executions.
        # Shape: `N_agts x T' x N_vts`, where `T'` is the length of the
        # initial sequence containing only the vertex positions.
        # * `idls`: real idlenesses for each agent while standing on a vertex
        #  for all executions.
        # Shape: `N_agts x T' x N_vts`, where `T` is the length of positions
        #  sequence containing only vertex positions.
        b_pos, viidls, vidls = cls.generate_binpos_and_idls(log_fp,
                                                            agts_log_fp)

        binpos_path = cls.create_log_path(log_rep=binpos_rep, tpl=tpl,
                                          strt=strt, variant=variant,
                                          nagts=nagts, exec_id=exec_id,
                                          duration=duration, ext="log.bin",
                                          soc_name=soc_name)

        viidls_path = cls.create_log_path(log_rep=viidls_rep, tpl=tpl,
                                          strt=strt, variant=variant,
                                          nagts=nagts, exec_id=exec_id,
                                          duration=duration,
                                          ext="log.viidls",
                                          soc_name=soc_name)

        vidls_path = cls.create_log_path(log_rep=vidls_rep, tpl=tpl,
                                         strt=strt, variant=variant,
                                         nagts=nagts, exec_id=exec_id,
                                         duration=duration,
                                         ext="log.vidls",
                                         soc_name=soc_name)

        with open(binpos_path, 'w') as s:
            json.dump(b_pos, s)

        with open(viidls_path, 'w') as s:
            json.dump(viidls, s)

        with open(vidls_path, 'w') as s:
            json.dump(vidls, s)

        return binpos_path, viidls_path, vidls_path

    @classmethod
    def generate_grouped_binpos_and_idls(cls,
                                         logs_dp: str):
        """
        Generates and saves in one file the on-vertex binary positions,
        on-vertex individual and on-vertex global idlenesses corresponding
        to the current scenario's logs. Described as grouped because all
        data are saved in one file.

        :param logs_dp:
        :type logs_dp:
        :return:
        :rtype:
        """

        log_files = sorted(
            filter(os.path.isfile and misc.is_log, os.listdir(logs_dp)),
            key=pf.execid_from_filename
        )
        agts_log_files = sorted(
            list(filter(os.path.isfile and misc.is_agts_log,
                        os.listdir(logs_dp))),
            key=pf.execid_from_filename
        )

        # Binary positions of all executions
        b_poss = []
        # On-vertex individual idlenesses of all executions
        viidlss = []
        # On-vertex idlenesses of all executions
        vidlss = []

        for i, l in enumerate(log_files):
            log_fp = "{}/{}".format(logs_dp, l)
            agts_log_fp = "{}/{}".format(logs_dp, agts_log_files[i])

            print("Inputs: ", log_fp, '\n', agts_log_fp, '\n')

            b_pos, viidls, vidls = \
                cls.generate_binpos_and_idls(log_fp=log_fp,
                                             agts_log_fp=agts_log_fp)

            b_poss.append(b_pos)
            viidlss.append(viidls)
            vidlss.append(vidls)

        return b_poss, viidlss, vidlss

    @classmethod
    def generate_save_grouped_binpos_and_idls(cls,
                                              logs_dp: str,
                                              soc_name: str = None,
                                              binpos_rep: str =
                                              Paths.LOCALBIN,
                                              viidls_rep: str =
                                              Paths.LOCALVIIDLS,
                                              vidls_rep: str =
                                              Paths.LOCALVIDLS):
        """
        Generates and saves in one file the on-vertex binary positions,
        on-vertex individual and on-vertex global idlenesses corresponding
        to the current scenario's logs. Described as grouped because all
        data are saved in one file.

        :param logs_dp: logs' directory path for the current scenario
        :type logs_dp: str
        :param soc_name:
        :type soc_name:
        :param binpos_rep: Repository of the binary position logs
        :type binpos_rep: str
        :param viidls_rep: Repository of the on-vertex individual
        idleness logs
        :type viidls_rep: str
        :param vidls_rep: Repository of the on-vertex real idleness logs
        :type vidls_rep: str
        :return:
        :rtype:
        """

        b_poss, viidlss, vidlss = cls.generate_grouped_binpos_and_idls(logs_dp)

        strt, variant, tpl, soc_name, nagts, duration = \
            pf.dirpath_to_exec_params(logs_dp, soc_name)

        binposs_path = cls.create_log_path(log_rep=binpos_rep, tpl=tpl,
                                           strt=strt, variant=variant,
                                           nagts=nagts,
                                           duration=duration, ext="log.bin",
                                           soc_name=soc_name)

        viidlss_path = cls.create_log_path(log_rep=viidls_rep, tpl=tpl,
                                           strt=strt, variant=variant,
                                           nagts=nagts,
                                           duration=duration,
                                           ext="log.viidls",
                                           soc_name=soc_name)

        vidlss_path = cls.create_log_path(log_rep=vidls_rep, tpl=tpl,
                                          strt=strt, variant=variant,
                                          nagts=nagts,
                                          duration=duration,
                                          ext="log.vidls",
                                          soc_name=soc_name)

        with open(binposs_path, 'w') as s:
            json.dump(b_poss, s)

        with open(viidlss_path, 'w') as s:
            json.dump(viidlss, s)

        with open(vidlss_path, 'w') as s:
            json.dump(vidlss, s)

        print("Outputs: ", binposs_path, '\n', viidlss_path, '\n',
              vidlss_path, '\n')

        return binposs_path, viidlss_path, vidlss_path

    @classmethod
    def generate_veidls_and_idls(cls,
                                 tpl: str,
                                 log_fp: str,
                                 agts_log_fp: str,
                                 est_log_fp: str):
        """

        :param est_log_fp: log's path of the current execution
        :type est_log_fp: str
        :param log_fp: file path of the log file of a given execution,
        containing 3D-positions of agents to process
        :type log_fp: str
        :param agts_log_fp: path of the log file of a given execution,
        containing the individual idlenesses of agents
        :type agts_log_fp:
        :param tpl: map id
        :type tpl: int or str
        :return:
        :rtype:
        """

        graph, seqs_pos, seqs_ridls, mts, seqs_viidls \
            = cls.load_log(log_fp=log_fp, tpl=tpl, agts_log_fp=agts_log_fp)

        seqs_veidls = []

        if est_log_fp is not None:
            with open(est_log_fp, 'r') as s:
                seqs_veidls = json.load(s)

        # * `veidls`: estimated idlenesses for each agent while standing on
        # a vertex for all executions.
        # Shape: `N_agts x T' x N_vts`, where `T'` is the length of the
        # initial sequence containing only the vertex positions.
        # * `viidls`: individual idlenesses for each agent while standing on
        # a vertex for all executions.
        # Shape: `N_agts x T' x N_vts`, where `T'` is the length of the
        # initial sequence containing only the vertex positions.
        # * `idls`: real idlenesses for each agent while standing on a vertex
        #  for all executions.
        # Shape: `N_agts x T' x N_vts`, where `T` is the length of positions
        #  sequence containing only vertex positions.
        return cls.log_to_veidls_and_idls(seqs_pos,
                                          seqs_viidls,
                                          seqs_veidls,
                                          seqs_ridls)

    @classmethod
    def generate_save_veidls_and_idls(cls,
                                      strt: str,
                                      nagts,
                                      duration: int,
                                      exec_id: int,
                                      tpl: str,
                                      log_fp: str,
                                      agts_log_fp: str,
                                      est_log_fp: str,
                                      variant: str = "0.2",
                                      soc_name: str = None,
                                      viidls_rep: str = Paths.LOCALVIIDLS,
                                      vidls_rep: str = Paths.LOCALVIDLS,
                                      veidls_rep: str = Paths.LOCALVEIDLS) \
            -> (str, str, str):
        """


        :param veidls_rep:
        :type veidls_rep:
        :param est_log_fp: estimated idlenesses' log's path of the of the
        current execution
        :type est_log_fp: str
        :param strt:
        :type strt:
        :param nagts:
        :type nagts:
        :param duration:
        :type duration:
        :param exec_id:
        :type exec_id:
        :param soc_name:
        :type soc_name:
        :param variant:
        :type variant:
        :param log_fp: file path of the log file of a given execution,
        containing 3D-positions of agents to process
        :type log_fp: str
        :param agts_log_fp: path of the log file of a given execution,
        containing the individual idlenesses of agents
        :type agts_log_fp:
        :param viidls_rep: Repository of the on-vertex individual
        idleness logs
        :type viidls_rep: str
        :param vidls_rep: Repository of the on-vertex real idleness logs
        :type vidls_rep: str
        :param tpl: map id
        :type tpl: int or str
        :return:
        :rtype:
        """

        # * `veidls`: estimated idlenesses for each agent while standing on
        # a vertex for all executions.
        # Shape: `N_agts x T' x N_vts`, where `T'` is the length of the
        # initial sequence containing only the vertex positions.
        # * `viidls`: individual idlenesses for each agent while standing on
        # a vertex for all executions.
        # Shape: `N_agts x T' x N_vts`, where `T'` is the length of the
        # initial sequence containing only the vertex positions.
        # * `idls`: real idlenesses for each agent while standing on a vertex
        #  for all executions.
        # Shape: `N_agts x T' x N_vts`, where `T` is the length of positions
        #  sequence containing only vertex positions.
        veidls, viidls, vidls = cls. \
            generate_veidls_and_idls(tpl=tpl,
                                     log_fp=log_fp,
                                     agts_log_fp=agts_log_fp,
                                     est_log_fp=est_log_fp)

        veidls_path = cls.create_log_path(log_rep=veidls_rep, tpl=tpl,
                                          strt=strt, variant=variant,
                                          nagts=nagts, exec_id=exec_id,
                                          duration=duration, ext="log.veidls",
                                          soc_name=soc_name)

        viidls_path = cls.create_log_path(log_rep=viidls_rep, tpl=tpl,
                                          strt=strt, variant=variant,
                                          nagts=nagts, exec_id=exec_id,
                                          duration=duration,
                                          ext="log.viidls",
                                          soc_name=soc_name)

        vidls_path = cls.create_log_path(log_rep=vidls_rep, tpl=tpl,
                                         strt=strt, variant=variant,
                                         nagts=nagts, exec_id=exec_id,
                                         duration=duration,
                                         ext="log.vidls",
                                         soc_name=soc_name)

        with open(veidls_path, 'w') as s:
            json.dump(veidls, s)

        with open(viidls_path, 'w') as s:
            json.dump(viidls, s)

        with open(vidls_path, 'w') as s:
            json.dump(vidls, s)

        return veidls_path, viidls_path, vidls_path
